GLOBALLY LOOK AT OBJECT CLEANUP (del's)


spin up plugins, built primary point
    one 'parse_message'

on message reciept, build a new Message object
this is what gets passed through the plugins

message should have a flag on it to keep processing or not

-the plugins add themselves as deferred if they need to handle every message or - ?
- otherwise the primary parse_message is added to the deferred


can i mix twisted w/ gevent? what will happen?

one action (message, mode change, user joined) in can -> n lines out
1:n


however we fire, we need to pass a reference to _this_ bot or the last callback has to be on the calling bot



In general, an object that makes a Deferred should also be in charge of firing that Deferred.
This “you make it, you fire it” rule helps ensure a given deferred is only fired once and
makes it easier to follow the flow of control in a Twisted program.



privmsg user, channel, message
joined channel



want plugins to be able to add 'handle_join'



so every 'event' will fire
    bot can fire these, no reason to have another level of abstraction



MESSAGE RECIEVED:
bot:
    privmsg()
        e = Event()
        i = Interaction(recieved=e)





message handling shoudl just be a deferred chain:
 d.addCallback(log_message)
 d.addErrback(handle_log_fail)




 d.addBoth(

 #
 plugins should expose a 'send' feature that should append a callback to msg whatever was passed in
 and a way to catch failures



plugin_handler()
    creates a deffered


deferred only get called _once_
we need to create a new one for every message recieved
every received event will call these callbacks



message reponses should be in a [,]
that way if we have a final list of results in the following  [kick, [msg, msg, msg], join,]
all of the msgs will get queued together on the bot (no defer, just straight calls)


google how to reuse/copy a deferred without having to recreate the chain everytime. just feels like this is a _lot_ of calls per message
otherwise i'll have to have a 'handle_message'




logfile should be stored in settings, not on bot
google










from bottes import __version__ as botte_core_version

__init__:
    self.handler = base.BaseHandler(self) #jeeves.core.handlers

signedOn:
    self.handler.load_plugins()

privmsg:
    self.handler.message(user,channel.msg)

Plugins()
    def




LoggingPlugin()
    __init__ (self)
        self.file = None
        self.date = None
        self.startlog()
        self.register_all() # will tell it to pick up all events
        self.global_continue = True # will tell the plugin manager to continue executing after this

    def start_log(filename):
        #self.file.
        #open(self.factory.filename, "a")

    def close(self):
        self.file.close()

    def log(self, message)
        now = time.localtime(time.time())

        if self.file is None:
            if now.date > self.date:
                self.close()
                self.

        timestamp = time.strftime("[%H:%M:%S]", time.localtime(time.time()))
        self.file.write('{0} {1}\n'.format(timestamp, message))
        self.file.flush()

    def got_CONNECTIONMADE():
        self.log("[connected at %s]" %
    def got_MESSAGE():
        self.log("generic catch all for all messages")




# When channel == self.nickname, the message was sent to the bot
# directly and not to a channel. So we will answer directly too:



basehandler
    __init__
        self._command_plugins {}
        self._generic_plugins []

    def load_plugins
        for plugin_path in settings.PLUGINS

        *dynamically loads plugin trolololol

    def message(self, user, channel, msg)
        user = user.split('!', 1)[0]
        nic, command, message = utils.parse_message(msg, self._command_plugins.keys())

        for plugin in self._generic_plugins
            plugin.handle_message(channel, nickname, message)

        if nick or channel == settings.NICKNAME and command
            self._command_plugins[command].handle_message(channel, nickname, message, command)




#file size limit on downloads (from http)